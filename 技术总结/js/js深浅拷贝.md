# js的深浅拷贝
> 2018.08.20
## 前言
    在编写业务的时候会用到一些浅拷贝的方法，一直对这个知识点懵懵懂懂，趁着有时间把这个知识点搞定。
## 正文
### 一、了解js的数据类型
    栈（stack）为自动分配的内存空间，它由系统自动释放；而堆（heap）则是动态分配的内存，大小不定也不会自动释放。
#### 1.基本数据类型
- include: null、Number、String、Boolen、Undefined
- 特点：基本数据类型的原始值是不可改变的，每次修改其实都是对变量重新赋值，根本不会修改到其原始值
- 存储位置：存储在栈中。
- 比较方式：原始值比较（在全等的情况下），先转换为响应的数据类型再比较（非全等的情况下）
#### 2.引用数据类型
- include: Object、Array、Function
- 特点：其原始值可以被修改
- 存储位置：内容存放在堆中，而其变量是存储其地址，这个地址是个基本数据类型，故存储在栈中
- 比较方式：引用数据类型比较，比较简单直接比较地址是否相同，不管内容是否相同，只要其地址相同即可。
![image](/img/15.jpg)
### 二、深浅拷贝和赋值
#### 1.赋值（=）
基本数据类型的赋值，是直接把原始值赋值给另一个变量，赋值后两个变量修改不会相互影响；引用数据类赋值是将地址赋值给变量，由于两个变量的地址都指向同一个堆中的内存块，故修改会相互影响
#### 2.浅拷贝
浅拷贝过程：首先会会在堆中声明一个内存块，然后对要拷贝的引用类型对其进行第一层进行拷贝，意思就是这个引用类型中的基本数据类型和引用数据类型会通过赋值（=）的方式进行拷贝，所以对浅拷贝后的其内部的基本数据类型不会对原引用类型的造成影响，只有其内部的引用数据类型会有影响，因为其地址指向的是同一块堆内存。
#### 3、深拷贝
深拷贝过程：首先会在堆中声明一块内存，然后进行拷贝时基本数据类型会使用赋值（=),而引用数据类型则会再在堆中声明一块内存，然后继续用上面的逻辑递归拷贝。
### 三、深浅拷贝的实现
#### 1.浅拷贝实现
- Object.assign()
- Array.prototype.concat()
- Array.prototype.slice()
- 自己手动赋值实现，先创建一个空对象，然后变量其内容进行赋值
#### 2.深拷贝
- JSON.parse(JSON.stringify())(只能处理对象和数组，不能处理函数)
- 手动递归实现
## 参考文章
- [浅拷贝与深拷贝](https://juejin.im/post/5b5dcf8351882519790c9a2e)
- [js 深拷贝 vs 浅拷贝](https://juejin.im/post/59ac1c4ef265da248e75892b#comment)